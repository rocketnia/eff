-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package eff
@version 0.0.0.0

module Control.Effect.Internal

-- | The kind of effect handlers, which are monad transformers.
type HandlerK = (Type -> Type) -> Type -> Type

-- | The kind of effects, which are classes of monads.
type EffectK = (Type -> Type) -> Constraint

-- | A monad transformer for handling effects. <tt>(<a>EffT</a> t)</tt> is
--   actually no different from <tt>t</tt> at runtime, but it provides a
--   different set of instances. Wrapping a monad transformer with
--   <a>EffT</a> allows other effects to be automatically lifted through
--   it, provided the underlying transformer provides a
--   <a>MonadTransControl</a> instance.
--   
--   <a>EffT</a> cannot be used with any arbitrary monad transformer: all
--   monad transformers wrapped with <a>EffT</a> <i>must</i> provide an
--   instance of the <a>Handles</a> type family to cooperate with effect
--   with the effect lifting machinery. However, note that this requirement
--   only applies to transformers wrapped in <a>EffT</a> directly, i.e.
--   used as the <tt>t</tt> argument in <tt>(<a>EffT</a> t)</tt>; there are
--   no restrictions placed on the underlying monad (though effects will
--   not be able to be automatically lifted through non-<a>EffT</a>
--   layers).
newtype EffT (t :: HandlerK) m a
EffT :: t m a -> EffT (t :: HandlerK) m a
[runEffT] :: EffT (t :: HandlerK) m a -> t m a

-- | A type alias for a stack of nested <a>EffT</a> transformers:
--   <tt><a>EffsT</a> '[t1, t2, ..., tn] m</tt> is equivalent to
--   <tt><a>EffT</a> t1 (<a>EffT</a> t2 (... (<a>EffT</a> tn m) ...))</tt>.
--   
--   This can be considered the implementation dual to the <a>Can</a>
--   interface.
type family EffsT ts m

-- | A helper for defining effect handlers in terms of other, existing
--   handlers. <tt>(<a>HandlerT</a> tag ts)</tt> is equivalent to
--   <tt>(<a>EffsT</a> ts)</tt>, but the phantom <tt>tag</tt> parameter is
--   useful as a way to disambiguate between different handler instances.
newtype HandlerT tag ts m a
HandlerT :: EffsT ts m a -> HandlerT tag ts m a
[runHandlerT] :: HandlerT tag ts m a -> EffsT ts m a
class Monad (EffsT ts m) => MonadTransHandler tag ts m
liftHandler :: MonadTransHandler tag ts m => m a -> HandlerT tag ts m a
class LowerHandler tag t ts m
lowerHandlerWith :: LowerHandler tag t ts m => Run (EffT t) -> Run (HandlerT tag ts) -> HandlerT tag (t : ts) m a -> m (StEffsT (t : ts) a)
class MonadTransHandler tag ts m => MonadTransControlHandler tag ts m where {
    type family StEffsT ts a;
}
liftHandlerWith :: MonadTransControlHandler tag ts m => (Run (HandlerT tag ts) -> m a) -> HandlerT tag ts m a
restoreHandlerT :: MonadTransControlHandler tag ts m => m (StEffsT ts a) -> HandlerT tag ts m a

-- | An open type family that is used to determine which effects ought to
--   be handled by which handlers. If <tt><a>Handles</a> t eff</tt> ~
--   '<a>True</a> for some handler <tt>t</tt> and effect <tt>eff</tt>, the
--   handler will be used to handle any effects sent to it via <a>send</a>;
--   otherwise, the effect will be lifted to the next handler in the stack.
--   
--   It is important that <tt><a>Handles</a> t</tt> is total in its
--   argument; that is, it is important that effects that <i>cannot</i> be
--   handled produce <tt>'<a>False</a></tt>, not just that effects that can
--   be handled produce <tt>'<a>True</a></tt>. The <a>==</a> type family is
--   provided for this purpose: If a handler only handles a single effect,
--   its <a>Handles</a> instance should look like the following:
--   
--   <pre>
--   type <a>Handles</a> MyEffectT eff = eff <a>==</a> MyEffect
--   </pre>
--   
--   If it handles multiple effects, it can use the <a>Elem</a> type family
--   instead:
--   
--   <pre>
--   type <a>Handles</a> MyEffectT eff = eff `<a>Elem</a>` '[MyEffect1, MyEffect2]
--   </pre>
--   
--   More complex <a>Handles</a> instances are possible, but not generally
--   very useful.
type family Handles (t :: HandlerK) (eff :: EffectK) :: Bool

-- | Boolean equality on types.
--   
--   This is essentially the same as <tt>==</tt> from
--   <a>Data.Type.Equality</a>, but the version from
--   <a>Data.Type.Equality</a> is written in such a way that allows GHC to
--   deduce more information from <tt>'<a>True</a></tt> results but causes
--   trouble when trying to compute the equality of rigid type variables.
--   This definition uses a simpler version.
type family a == b

-- | Checks if <tt>x</tt> is in the type-level list <tt>xs</tt> (like
--   <a>elem</a>, but at the type level).
type family Elem (x :: k) (xs :: [k]) :: Bool
class Handle (handles :: Bool) eff t m
handle :: Handle handles eff t m => (eff (t m) => t m a) -> ((MonadTransControl t, eff m) => t m a) -> EffT t m a

-- | A typeclass used to lift effectful actions into effect handlers. This
--   is not necessary to use directly when using effects, but it is used as
--   part of defining new effects. Every effect should be given an instance
--   on <a>EffT</a> of the shape
--   
--   <pre>
--   instance <a>Send</a> <i>eff</i> t m =&gt; <i>eff</i> (<a>EffT</a> t m) where
--   </pre>
--   
--   where <tt><i>eff</i></tt> is replaced by the actual effect in
--   question. Each method should be implemented using <a>send</a> or
--   <a>sendWith</a>: <a>send</a> for algebraic/first-order operations and
--   <a>sendWith</a> for scoped/higher-order ones.
--   
--   There is no need to define any additional instances of this class.
class (Monad m, Handle (Handles t eff) eff t m) => Send eff t m

-- | Constructs an <tt><a>EffT</a> t m a</tt> computation for an
--   algebraic/first-order operation. Each first-order method in the
--   <a>EffT</a> instance for a given effect should have the shape
--   
--   <pre>
--   <i>method</i> <i>a</i> <i>b</i> <i>c</i> = <a>send</a> @<i>eff</i> (<i>method</i> <i>a</i> <i>b</i> <i>c</i>)
--   </pre>
--   
--   where <tt><i>method</i> <i>a</i> <i>b</i> <i>c</i></tt> should be
--   replaced with the method and its arguments, and <tt><i>eff</i></tt>
--   should be replaced with the type of the effect. The explicit type
--   application is necessary because <tt>eff</tt> only appears in a
--   constraint in the type signature for <a>send</a>, which GHC cannot
--   automatically infer.
--   
--   <tt><a>send</a> @<i>eff</i> <i>m</i></tt> is equivalent to
--   <tt><a>sendWith</a> @<i>eff</i> <i>m</i> (<a>lift</a> <i>m</i>)</tt>.
send :: Send eff t m => (forall n. eff n => n a) -> EffT t m a

-- | Constructs an <tt><a>EffT</a> t m a</tt> computation for a
--   higher-order/scoped effect <tt>eff</tt> from two actions:
--   
--   <ol>
--   <li>A “run” action, which executes the effect in the <tt>(t m)</tt>
--   monad given <tt>(t m)</tt> has an instance of <tt>eff</tt>.</li>
--   <li>A “lift” action, which lifts the effect through <tt>(t m)</tt>
--   into <tt>m</tt> given that <tt>t</tt> has a <a>MonadTransControl</a>
--   instance and <tt>m</tt> has an instance of <tt>eff</tt>.</li>
--   </ol>
--   
--   Each higher-order method in the <a>EffT</a> instance for a given
--   effect should use <a>sendWith</a> to specify how it ought to be lifted
--   through effect handlers. For example, the definition of <a>local</a>
--   looks like this:
--   
--   <pre>
--   <a>local</a> f m = <a>sendWith</a> @(<a>Reader</a> r)
--     (<a>local</a> f (<a>runEffT</a> m))
--     (<a>controlT</a> <a>$</a> \lower -&gt; <a>local</a> f (lower <a>$</a> <a>runEffT</a> m))
--   </pre>
--   
--   With this instance in place, <tt><a>Reader</a> r</tt> can
--   automatically be used with <tt><a>EffT</a> t m a</tt>. Transformers
--   that can handle the <tt><a>Reader</a> r</tt> effect (i.e. ones for
--   which <tt><a>Handles</a> t (<a>Reader</a> r) ~ '<a>True</a></tt>) will
--   use their <tt><a>Reader</a> r</tt> instances, while other transformers
--   will delegate to the underlying monad.
sendWith :: Send eff t m => (eff (t m) => t m a) -> ((MonadTransControl t, eff m) => t m a) -> EffT t m a

-- | Using <a>MonadTransControl</a>, lifts a higher-order effectful
--   operation into the underlying monad. It is named by analogy to
--   <a>control</a>, since both are intended for lifting “control
--   operations,” i.e. operations that affect control flow.
--   
--   <tt><a>controlT</a> f</tt> is equivalent to <tt><a>restoreT</a>
--   <a>.</a> <a>pure</a> =&lt;&lt; <a>liftWith</a> f</tt>, but it is rare
--   that <a>restoreT</a> or <a>liftWith</a> need to be used directly.
controlT :: (MonadTransControl t, Monad m, Monad (t m)) => (Run t -> m (StT t a)) -> t m a
type family All (cs :: [k -> Constraint]) (a :: k) :: Constraint

-- | A helper type for combining effect constraints: <tt>(<a>Can</a> '[e1,
--   e2, e3, ..., en] m)</tt> is equivalent to <tt>(e1 m, e2 m, e3 m, ...,
--   en m)</tt>. The constraint <tt><a>Can</a> effs m</tt> should be read
--   as specifying that the monad <tt>m</tt> <i>can</i> perform all of the
--   effects in the list <tt>effs</tt>.
class All effs m => Can (effs :: [EffectK]) m
instance Control.Monad.Trans.Control.MonadTransControl t => Control.Monad.Trans.Control.MonadTransControl (Control.Effect.Internal.EffT t)
instance Control.Monad.Trans.Class.MonadTrans t => Control.Monad.Trans.Class.MonadTrans (Control.Effect.Internal.EffT t)
instance GHC.Base.Monad (t m) => GHC.Base.Monad (Control.Effect.Internal.EffT t m)
instance GHC.Base.Applicative (t m) => GHC.Base.Applicative (Control.Effect.Internal.EffT t m)
instance GHC.Base.Functor (t m) => GHC.Base.Functor (Control.Effect.Internal.EffT t m)
instance forall k (ts :: [Control.Effect.Internal.HandlerK]) (m :: * -> *) (tag :: k). GHC.Base.Functor (Control.Effect.Internal.EffsT ts m) => GHC.Base.Functor (Control.Effect.Internal.HandlerT tag ts m)
instance forall k (ts :: [Control.Effect.Internal.HandlerK]) (m :: * -> *) (tag :: k). GHC.Base.Applicative (Control.Effect.Internal.EffsT ts m) => GHC.Base.Applicative (Control.Effect.Internal.HandlerT tag ts m)
instance forall k (ts :: [Control.Effect.Internal.HandlerK]) (m :: * -> *) (tag :: k). GHC.Base.Alternative (Control.Effect.Internal.EffsT ts m) => GHC.Base.Alternative (Control.Effect.Internal.HandlerT tag ts m)
instance forall k (ts :: [Control.Effect.Internal.HandlerK]) (m :: * -> *) (tag :: k). GHC.Base.Monad (Control.Effect.Internal.EffsT ts m) => GHC.Base.Monad (Control.Effect.Internal.HandlerT tag ts m)
instance forall k (ts :: [Control.Effect.Internal.HandlerK]) (m :: * -> *) (tag :: k). GHC.Base.MonadPlus (Control.Effect.Internal.EffsT ts m) => GHC.Base.MonadPlus (Control.Effect.Internal.HandlerT tag ts m)
instance forall k (ts :: [Control.Effect.Internal.HandlerK]) (m :: * -> *) (tag :: k). Control.Monad.IO.Class.MonadIO (Control.Effect.Internal.EffsT ts m) => Control.Monad.IO.Class.MonadIO (Control.Effect.Internal.HandlerT tag ts m)
instance forall k (b :: * -> *) (ts :: [Control.Effect.Internal.HandlerK]) (m :: * -> *) (tag :: k). (GHC.Base.Monad b, Control.Monad.Base.MonadBase b (Control.Effect.Internal.EffsT ts m)) => Control.Monad.Base.MonadBase b (Control.Effect.Internal.HandlerT tag ts m)
instance forall k (b :: * -> *) (ts :: [Control.Effect.Internal.HandlerK]) (m :: * -> *) (tag :: k). (GHC.Base.Monad b, Control.Monad.Trans.Control.MonadBaseControl b (Control.Effect.Internal.EffsT ts m)) => Control.Monad.Trans.Control.MonadBaseControl b (Control.Effect.Internal.HandlerT tag ts m)
instance Control.Effect.Internal.All effs m => Control.Effect.Internal.Can effs m
instance (Control.Effect.Internal.Send GHC.Base.Alternative t m, GHC.Base.Monad (t m)) => GHC.Base.Alternative (Control.Effect.Internal.EffT t m)
instance (Control.Effect.Internal.Send GHC.Base.Alternative t m, GHC.Base.Monad (t m)) => GHC.Base.MonadPlus (Control.Effect.Internal.EffT t m)
instance (GHC.Base.Monad m, Control.Effect.Internal.Handle (Control.Effect.Internal.Handles t eff) eff t m) => Control.Effect.Internal.Send eff t m
instance eff (t m) => Control.Effect.Internal.Handle 'GHC.Types.True eff t m
instance (Control.Monad.Trans.Control.MonadTransControl t, eff m) => Control.Effect.Internal.Handle 'GHC.Types.False eff t m
instance forall k (m :: * -> *) (ts :: [Control.Effect.Internal.HandlerK]) (tag :: k) (t :: Control.Effect.Internal.HandlerK). (GHC.Base.Monad m, GHC.Base.Monad (Control.Effect.Internal.EffsT ts m)) => Control.Effect.Internal.LowerHandler tag t ts m
instance forall k (t :: (* -> *) -> * -> *) (tag :: k) (ts :: [Control.Effect.Internal.HandlerK]) (m :: * -> *). (forall (n :: * -> *). GHC.Base.Monad n => GHC.Base.Monad (t n), Control.Monad.Trans.Control.MonadTransControl t, Control.Effect.Internal.MonadTransControlHandler tag ts m, forall (n :: * -> *). GHC.Base.Monad n => Control.Effect.Internal.LowerHandler tag t ts n) => Control.Effect.Internal.MonadTransControlHandler tag (t : ts) m
instance forall k (m :: * -> *) (tag :: k). GHC.Base.Monad m => Control.Effect.Internal.MonadTransControlHandler tag '[] m
instance forall k (tag :: k) (ts :: [Control.Effect.Internal.HandlerK]). (forall (m :: * -> *). GHC.Base.Monad m => Control.Effect.Internal.MonadTransControlHandler tag ts m) => Control.Monad.Trans.Control.MonadTransControl (Control.Effect.Internal.HandlerT tag ts)
instance forall k (m :: * -> *) (tag :: k). GHC.Base.Monad m => Control.Effect.Internal.MonadTransHandler tag '[] m
instance forall k (t :: (* -> *) -> * -> *) (tag :: k) (ts :: [Control.Effect.Internal.HandlerK]) (m :: * -> *). (forall (n :: * -> *). GHC.Base.Monad n => GHC.Base.Monad (t n), Control.Monad.Trans.Class.MonadTrans t, Control.Effect.Internal.MonadTransHandler tag ts m) => Control.Effect.Internal.MonadTransHandler tag (t : ts) m
instance forall k (tag :: k) (ts :: [Control.Effect.Internal.HandlerK]). (forall (m :: * -> *). GHC.Base.Monad m => Control.Effect.Internal.MonadTransHandler tag ts m) => Control.Monad.Trans.Class.MonadTrans (Control.Effect.Internal.HandlerT tag ts)
instance (Control.Monad.IO.Class.MonadIO m, Control.Monad.Trans.Class.MonadTrans t, GHC.Base.Monad (t m)) => Control.Monad.IO.Class.MonadIO (Control.Effect.Internal.EffT t m)
instance (Control.Monad.Base.MonadBase b m, Control.Monad.Trans.Class.MonadTrans t, GHC.Base.Monad (t m)) => Control.Monad.Base.MonadBase b (Control.Effect.Internal.EffT t m)
instance (Control.Monad.Trans.Control.MonadBaseControl b m, Control.Monad.Trans.Control.MonadTransControl t, GHC.Base.Monad (t m)) => Control.Monad.Trans.Control.MonadBaseControl b (Control.Effect.Internal.EffT t m)

module Control.Effect.Reader

-- | <tt><a>Reader</a> r</tt> is an effect that provides access to a global
--   environment of type <tt>r</tt>.
--   
--   Instances should obey the law <tt>f <a>&lt;$&gt;</a> <a>ask</a></tt> ≡
--   <tt><a>asks</a> f</tt> ≡ <tt><a>local</a> f <a>ask</a></tt>.
class Monad m => Reader r m

-- | Retrieves a value from the environment.
ask :: Reader r m => m r

-- | Applies a function to a value in the environment and returns the
--   result.
asks :: Reader r m => (r -> a) -> m a

-- | Runs a subcomputation in an environment modified by the given
--   function.
local :: Reader r m => (r -> r) -> m a -> m a

-- | Handles a <tt><a>Reader</a> r</tt> effect by supplying a value for the
--   environment.
runReader :: r -> EffT (ReaderT r) m a -> m a

-- | The reader monad transformer, which adds a read-only environment to
--   the given monad.
--   
--   The <a>return</a> function ignores the environment, while
--   <tt>&gt;&gt;=</tt> passes the inherited environment to both
--   subcomputations.
data ReaderT r (m :: Type -> Type) a
instance (GHC.Base.Monad (t m), Control.Effect.Internal.Send (Control.Effect.Reader.Reader r) t m) => Control.Effect.Reader.Reader r (Control.Effect.Internal.EffT t m)
instance GHC.Base.Monad m => Control.Effect.Reader.Reader r (Control.Monad.Trans.Reader.ReaderT r m)

module Control.Effect.Error

-- | <tt><a>Error</a> e</tt> is an effect that allows throwing and catching
--   errors of type <tt>e</tt>. Note that these have no relation to
--   Haskell’s built-in support for synchronous or asynchronous runtime
--   exceptions provided from <a>Control.Exception</a>.
--   
--   Instances should obey the law <tt><a>catch</a> (<a>throw</a> x) f</tt>
--   ≡ <tt><a>pure</a> (f x)</tt>.
class Monad m => Error e m

-- | Raises an error of type <tt>e</tt>.
throw :: Error e m => e -> m a

-- | Runs the given sub-computation. If it raises an error of type
--   <tt>e</tt>, the error is provided to the given handler function, and
--   execution resumes from the point of the call to <a>catch</a>.
catch :: Error e m => m a -> (e -> m a) -> m a

-- | Handles an <tt><a>Error</a> e</tt> effect. Returns <a>Left</a> if the
--   computation raised an uncaught error, otherwise returns <a>Right</a>.
runError :: EffT (ExceptT e) m a -> m (Either e a)

-- | A monad transformer that adds exceptions to other monads.
--   
--   <tt>ExceptT</tt> constructs a monad parameterized over two things:
--   
--   <ul>
--   <li>e - The exception type.</li>
--   <li>m - The inner monad.</li>
--   </ul>
--   
--   The <a>return</a> function yields a computation that produces the
--   given value, while <tt>&gt;&gt;=</tt> sequences two subcomputations,
--   exiting on the first exception.
data ExceptT e (m :: Type -> Type) a
instance (GHC.Base.Monad (t m), Control.Effect.Internal.Send (Control.Effect.Error.Error e) t m) => Control.Effect.Error.Error e (Control.Effect.Internal.EffT t m)
instance GHC.Base.Monad m => Control.Effect.Error.Error e (Control.Monad.Trans.Except.ExceptT e m)

module Control.Effect.State

-- | <tt><a>State</a> s</tt> is an effect that provides access to a single
--   cell of mutable state of type <tt>s</tt>.
class Monad m => State s m

-- | Retrieves the current value of the state.
get :: State s m => m s

-- | Replaces the current state with the given value.
put :: State s m => s -> m ()

-- | Modifies the current state by applying the given function to it.
modify :: State s m => (s -> s) -> m ()
runState :: Functor m => s -> EffT (StateT s) m a -> m (s, a)
evalState :: Monad m => s -> EffT (StateT s) m a -> m a
execState :: Monad m => s -> EffT (StateT s) m a -> m s

-- | A state transformer monad parameterized by:
--   
--   <ul>
--   <li><tt>s</tt> - The state.</li>
--   <li><tt>m</tt> - The inner monad.</li>
--   </ul>
--   
--   The <a>return</a> function leaves the state unchanged, while
--   <tt>&gt;&gt;=</tt> uses the final state of the first computation as
--   the initial state of the second.
data StateT s (m :: Type -> Type) a
instance (GHC.Base.Monad (t m), Control.Effect.Internal.Send (Control.Effect.State.State s) t m) => Control.Effect.State.State s (Control.Effect.Internal.EffT t m)
instance GHC.Base.Monad m => Control.Effect.State.State s (Control.Monad.Trans.State.Strict.StateT s m)


-- | This module provides a set of classes and operations for safe resource
--   allocation and disposal.
module Control.Effect.Resource

-- | An effect that provides the ability to temporarily mask asynchronous
--   interrupts.
--   
--   Unlike most effects, this effect does not have its own handler; there
--   is no separate <tt>runMask</tt> operation. This is because the usual
--   handler for <a>Mask</a> is <a>IO</a>, which is always at the base of a
--   monad transformer stack.
--   
--   <a>Mask</a> may be used in pure computations (where both <a>mask</a>
--   and <a>uninterruptibleMask</a> are no-ops), but it can only be
--   discharged by <a>runIdentity</a>, which serves as a proof that the
--   computation is, in fact, pure.
class Monad m => Mask m

-- | Executes a computation with asynchronous interrupts masked; see
--   <tt><a>Control.Exception</a>.<a>mask</a></tt> for details.
mask :: Mask m => ((forall a. m a -> m a) -> m b) -> m b

-- | Executes a computation with asynchronous interrupts uninterruptibly
--   masked. <b>This should be used with great care</b>; see
--   <tt><a>Control.Exception</a>.<a>uninterruptibleMask</a></tt> for
--   details.
uninterruptibleMask :: Mask m => ((forall a. m a -> m a) -> m b) -> m b

-- | Like <a>mask</a>, but does not pass a <tt>restore</tt> action to its
--   argument.
mask_ :: Mask m => m a -> m a

-- | Like <a>uninterruptibleMask</a>, but does not pass a <tt>restore</tt>
--   action to its argument.
uninterruptibleMask_ :: Mask m => m a -> m a

-- | The class of monads that support registering cleanup actions on
--   failure. Note that this is <b>not</b> an effect; it cannot be
--   automatically lifted through <a>EffT</a> the way effects can. Doing so
--   would be unsafe, as different handlers may provide arbitrarily
--   different notions of failure, and they must supply <a>MonadUnwind</a>
--   instances to ensure those failures are not ignored. However, note that
--   any handlers defined using <a>HandlerT</a> do <i>not</i> need their
--   own <a>MonadUnwind</a> instances, as they will inherit the instance of
--   their underlying handlers.
class Monad m => MonadUnwind m

-- | <tt>(<i>a</i> `<a>onException</a>` <i>b</i>)</tt> runs
--   <tt><i>a</i></tt>. If and only if it fails with an error,
--   <tt><i>b</i></tt> is executed for side effects (with asynchronous
--   exceptions masked, if relevant), after which the error is re-raised.
--   If <tt><i>b</i></tt> fails with an error, its error takes priority
--   over the error raised by <tt><i>a</i></tt>.
--   
--   <a>onException</a> <i>cannot</i> generally be used to ensure the
--   disposal of an acquired resource because an asynchronous exception
--   might be raised after the resource is acquired but before the
--   exception handler is installed. For safe resource management, use
--   <a>bracket</a> or <a>bracketOnError_</a> instead.
--   
--   Note that because the error is re-raised after <tt><i>b</i></tt> is
--   executed, changes to the monadic state made by <tt><i>b</i></tt> will
--   be discarded for any effects handled more locally than the effect that
--   triggered the failure.
onException :: MonadUnwind m => m a -> m b -> m a

-- | <tt>(<a>Resource</a> m)</tt> is a constraint synonym for
--   <tt>(<a>Mask</a> m, <a>MonadUnwind</a> m)</tt>, which together provide
--   the operations necessary for safe resource allocation and disposal.
--   The most frequently used operations of <a>Resource</a> are
--   <a>bracket</a> and <a>bracketOnError</a>.
class (Mask m, MonadUnwind m) => Resource m

-- | Like <a>onException</a>, but the action provided for the second
--   argument is unconditionally executed, whether an error was raised or
--   not.
finally :: Resource m => m a -> m b -> m a

-- | Safely acquires a resource for the dynamic extent of a nested
--   computation given actions to acquire and dispose it. See also
--   <tt><a>Control.Exception</a>.<a>bracket</a></tt>.
bracket :: Resource m => m a -> (a -> m c) -> (a -> m b) -> m b

-- | Like <a>bracket</a>, but the return value from the first argument is
--   ignored.
bracket_ :: Resource m => m a -> m c -> m b -> m b

-- | Like <a>bracket</a>, but the dispose action is only executed if an
--   error is raised during the dynamic extent of the primary computation.
bracketOnError :: Resource m => m a -> (a -> m c) -> (a -> m b) -> m b

-- | Like <a>bracketOnError</a>, but the return value from the first
--   argument is ignored.
bracketOnError_ :: Resource m => m a -> m c -> m b -> m b
instance Control.Effect.Resource.MonadUnwind (t m) => Control.Effect.Resource.MonadUnwind (Control.Effect.Internal.EffT t m)
instance Control.Effect.Resource.MonadUnwind (Control.Effect.Internal.EffsT ts m) => Control.Effect.Resource.MonadUnwind (Control.Effect.Internal.HandlerT tag ts m)
instance (Control.Effect.Resource.Mask m, Control.Effect.Resource.MonadUnwind m) => Control.Effect.Resource.Resource m
instance Control.Effect.Resource.MonadUnwind Data.Functor.Identity.Identity
instance Control.Effect.Resource.MonadUnwind GHC.Types.IO
instance Control.Effect.Resource.MonadUnwind m => Control.Effect.Resource.MonadUnwind (Control.Monad.Trans.Reader.ReaderT r m)
instance Control.Effect.Resource.MonadUnwind m => Control.Effect.Resource.MonadUnwind (Control.Monad.Trans.State.Strict.StateT r m)
instance Control.Effect.Resource.MonadUnwind m => Control.Effect.Resource.MonadUnwind (Control.Monad.Trans.Except.ExceptT e m)
instance Control.Effect.Resource.Mask Data.Functor.Identity.Identity
instance Control.Effect.Resource.Mask GHC.Types.IO
instance (GHC.Base.Monad (t m), Control.Effect.Internal.Send Control.Effect.Resource.Mask t m) => Control.Effect.Resource.Mask (Control.Effect.Internal.EffT t m)


-- | This library is an implementation of an <i>extensible effect
--   system</i> for Haskell, a general-purpose solution for tracking
--   effects at the type level and handling them in flexible ways. The term
--   “effect” as used by this library is very general: it encompasses
--   things most people consider side-effects, such as generating random
--   values, interacting with the file system, or mutating state, but it
--   also includes globally-pure but locally-impure operations such as
--   access to an immutable global environment or exception handling.
--   
--   The traditional approach to effect composition in Haskell is <i>monad
--   transformers</i>, but programming against a concrete stack of monad
--   transformers can make reuse difficult and tethers a program to a
--   particular implementation of each effect. The <tt>mtl</tt> library
--   provides a partial solution to this problem by providing a typeclass
--   for each effect, which allow programmers to parameterize computations
--   over the monad they are executed in. However, that technique has
--   problems of its own, most notably that it requires <i>m</i>×<i>n</i>
--   instances be written for code that uses <i>m</i> distinct effects and
--   <i>n</i> distinct effect implementations.
--   
--   <tt>eff</tt> is a reformulation of <tt>mtl</tt> that avoids the
--   “quadratic instance” problem. Like <tt>mtl</tt>, it uses monad
--   transformers to represent effect implementations, which <tt>eff</tt>
--   calls effect <i>handlers</i>, and it uses typeclasses to represent
--   effects. Unlike <tt>mtl</tt>, <tt>eff</tt> uses a slightly different
--   encoding that allows explicit instances to be written <i>only</i> for
--   the effects handled by each transformer, requiring a linear rather
--   than quadratic number of instances. It achieves this without any use
--   of overlapping instances or Template Haskell by keeping track of a
--   little extra information at the type level that can be used to guide
--   instance selection.
--   
--   Generally speaking, this library provides two discrete (but related)
--   chunks of functionality:
--   
--   <ol>
--   <li>First, <tt>eff</tt> provides a library of common effects, such as
--   <a>Reader</a>, <a>Error</a>, and <a>State</a>, as well as handlers for
--   them. These can be used out of the box the same way
--   <tt>transformers</tt> and <tt>mtl</tt> can be, and they use a similar
--   interface.</li>
--   <li>Second, <tt>eff</tt> exposes the infrastructure necessary to
--   define <i>your own</i> effects and effect handlers, all of which
--   automatically cooperate with the built-in effects and any effects
--   defined in other libraries.</li>
--   </ol>
--   
--   Compared to other Haskell effect system libraries, such as
--   <tt>freer</tt>, <tt>polysemy</tt>, and <tt>fused-effects</tt>,
--   <tt>eff</tt> distinguishes itself in the following respects:
--   
--   <ul>
--   <li><tt>eff</tt> is, at the time of this writing, the fastest effect
--   system available. Its performance is equivalent to that of
--   <tt>mtl</tt>, which is slightly faster than <tt>fused-effects</tt> and
--   significantly faster than <tt>freer</tt> or <tt>polysemy</tt> on real
--   workloads. It is designed specifically to take advantage of the GHC
--   optimizer by cooperating with specialization as much as possible.</li>
--   <li><tt>eff</tt> integrates well with the existing
--   <tt>transformers</tt> ecosystem. Effect handlers in <tt>eff</tt> are
--   ordinary monad transformers, and many built-in effects are handled by
--   the ordinary transformers from the <tt>transformers</tt> package. As
--   in <tt>fused-effects</tt>, existing transformers can be easily adapted
--   into effect handlers, but <tt>eff</tt> goes a step further by allowing
--   existing <tt>mtl</tt>-style typeclasses to be used as effects, just by
--   defining a couple small instances.</li>
--   <li>Despite its use of monad transformers and its focus on
--   performance, defining effects and effect handlers in <tt>eff</tt>
--   requires relatively little boilerplate, though <tt>freer-simple</tt>
--   and <tt>polysemy</tt> provide some Template Haskell code that can
--   generate most of the boilerplate automatically. Providing similar
--   Template Haskell functionality is a future goal of this library, but
--   it as not yet been implemented.</li>
--   <li>Unlike <tt>freer</tt>, but like <tt>polysemy</tt> and
--   <tt>fused-effects</tt>, <tt>eff</tt> supports higher-order (or scoped)
--   effects, in addition to the more traditional algebraic effects.</li>
--   </ul>
module Control.Effect

-- | A helper type for combining effect constraints: <tt>(<a>Can</a> '[e1,
--   e2, e3, ..., en] m)</tt> is equivalent to <tt>(e1 m, e2 m, e3 m, ...,
--   en m)</tt>. The constraint <tt><a>Can</a> effs m</tt> should be read
--   as specifying that the monad <tt>m</tt> <i>can</i> perform all of the
--   effects in the list <tt>effs</tt>.
class All effs m => Can (effs :: [EffectK]) m

-- | The kind of effects, which are classes of monads.
type EffectK = (Type -> Type) -> Constraint

-- | A typeclass used to lift effectful actions into effect handlers. This
--   is not necessary to use directly when using effects, but it is used as
--   part of defining new effects. Every effect should be given an instance
--   on <a>EffT</a> of the shape
--   
--   <pre>
--   instance <a>Send</a> <i>eff</i> t m =&gt; <i>eff</i> (<a>EffT</a> t m) where
--   </pre>
--   
--   where <tt><i>eff</i></tt> is replaced by the actual effect in
--   question. Each method should be implemented using <a>send</a> or
--   <a>sendWith</a>: <a>send</a> for algebraic/first-order operations and
--   <a>sendWith</a> for scoped/higher-order ones.
--   
--   There is no need to define any additional instances of this class.
class (Monad m, Handle (Handles t eff) eff t m) => Send eff t m

-- | Constructs an <tt><a>EffT</a> t m a</tt> computation for an
--   algebraic/first-order operation. Each first-order method in the
--   <a>EffT</a> instance for a given effect should have the shape
--   
--   <pre>
--   <i>method</i> <i>a</i> <i>b</i> <i>c</i> = <a>send</a> @<i>eff</i> (<i>method</i> <i>a</i> <i>b</i> <i>c</i>)
--   </pre>
--   
--   where <tt><i>method</i> <i>a</i> <i>b</i> <i>c</i></tt> should be
--   replaced with the method and its arguments, and <tt><i>eff</i></tt>
--   should be replaced with the type of the effect. The explicit type
--   application is necessary because <tt>eff</tt> only appears in a
--   constraint in the type signature for <a>send</a>, which GHC cannot
--   automatically infer.
--   
--   <tt><a>send</a> @<i>eff</i> <i>m</i></tt> is equivalent to
--   <tt><a>sendWith</a> @<i>eff</i> <i>m</i> (<a>lift</a> <i>m</i>)</tt>.
send :: Send eff t m => (forall n. eff n => n a) -> EffT t m a

-- | Constructs an <tt><a>EffT</a> t m a</tt> computation for a
--   higher-order/scoped effect <tt>eff</tt> from two actions:
--   
--   <ol>
--   <li>A “run” action, which executes the effect in the <tt>(t m)</tt>
--   monad given <tt>(t m)</tt> has an instance of <tt>eff</tt>.</li>
--   <li>A “lift” action, which lifts the effect through <tt>(t m)</tt>
--   into <tt>m</tt> given that <tt>t</tt> has a <a>MonadTransControl</a>
--   instance and <tt>m</tt> has an instance of <tt>eff</tt>.</li>
--   </ol>
--   
--   Each higher-order method in the <a>EffT</a> instance for a given
--   effect should use <a>sendWith</a> to specify how it ought to be lifted
--   through effect handlers. For example, the definition of <a>local</a>
--   looks like this:
--   
--   <pre>
--   <a>local</a> f m = <a>sendWith</a> @(<a>Reader</a> r)
--     (<a>local</a> f (<a>runEffT</a> m))
--     (<a>controlT</a> <a>$</a> \lower -&gt; <a>local</a> f (lower <a>$</a> <a>runEffT</a> m))
--   </pre>
--   
--   With this instance in place, <tt><a>Reader</a> r</tt> can
--   automatically be used with <tt><a>EffT</a> t m a</tt>. Transformers
--   that can handle the <tt><a>Reader</a> r</tt> effect (i.e. ones for
--   which <tt><a>Handles</a> t (<a>Reader</a> r) ~ '<a>True</a></tt>) will
--   use their <tt><a>Reader</a> r</tt> instances, while other transformers
--   will delegate to the underlying monad.
sendWith :: Send eff t m => (eff (t m) => t m a) -> ((MonadTransControl t, eff m) => t m a) -> EffT t m a

-- | Using <a>MonadTransControl</a>, lifts a higher-order effectful
--   operation into the underlying monad. It is named by analogy to
--   <a>control</a>, since both are intended for lifting “control
--   operations,” i.e. operations that affect control flow.
--   
--   <tt><a>controlT</a> f</tt> is equivalent to <tt><a>restoreT</a>
--   <a>.</a> <a>pure</a> =&lt;&lt; <a>liftWith</a> f</tt>, but it is rare
--   that <a>restoreT</a> or <a>liftWith</a> need to be used directly.
controlT :: (MonadTransControl t, Monad m, Monad (t m)) => (Run t -> m (StT t a)) -> t m a

-- | The kind of effect handlers, which are monad transformers.
type HandlerK = (Type -> Type) -> Type -> Type

-- | A monad transformer for handling effects. <tt>(<a>EffT</a> t)</tt> is
--   actually no different from <tt>t</tt> at runtime, but it provides a
--   different set of instances. Wrapping a monad transformer with
--   <a>EffT</a> allows other effects to be automatically lifted through
--   it, provided the underlying transformer provides a
--   <a>MonadTransControl</a> instance.
--   
--   <a>EffT</a> cannot be used with any arbitrary monad transformer: all
--   monad transformers wrapped with <a>EffT</a> <i>must</i> provide an
--   instance of the <a>Handles</a> type family to cooperate with effect
--   with the effect lifting machinery. However, note that this requirement
--   only applies to transformers wrapped in <a>EffT</a> directly, i.e.
--   used as the <tt>t</tt> argument in <tt>(<a>EffT</a> t)</tt>; there are
--   no restrictions placed on the underlying monad (though effects will
--   not be able to be automatically lifted through non-<a>EffT</a>
--   layers).
newtype EffT (t :: HandlerK) m a
EffT :: t m a -> EffT (t :: HandlerK) m a
[runEffT] :: EffT (t :: HandlerK) m a -> t m a

-- | A type alias for a stack of nested <a>EffT</a> transformers:
--   <tt><a>EffsT</a> '[t1, t2, ..., tn] m</tt> is equivalent to
--   <tt><a>EffT</a> t1 (<a>EffT</a> t2 (... (<a>EffT</a> tn m) ...))</tt>.
--   
--   This can be considered the implementation dual to the <a>Can</a>
--   interface.
type family EffsT ts m

-- | An open type family that is used to determine which effects ought to
--   be handled by which handlers. If <tt><a>Handles</a> t eff</tt> ~
--   '<a>True</a> for some handler <tt>t</tt> and effect <tt>eff</tt>, the
--   handler will be used to handle any effects sent to it via <a>send</a>;
--   otherwise, the effect will be lifted to the next handler in the stack.
--   
--   It is important that <tt><a>Handles</a> t</tt> is total in its
--   argument; that is, it is important that effects that <i>cannot</i> be
--   handled produce <tt>'<a>False</a></tt>, not just that effects that can
--   be handled produce <tt>'<a>True</a></tt>. The <a>==</a> type family is
--   provided for this purpose: If a handler only handles a single effect,
--   its <a>Handles</a> instance should look like the following:
--   
--   <pre>
--   type <a>Handles</a> MyEffectT eff = eff <a>==</a> MyEffect
--   </pre>
--   
--   If it handles multiple effects, it can use the <a>Elem</a> type family
--   instead:
--   
--   <pre>
--   type <a>Handles</a> MyEffectT eff = eff `<a>Elem</a>` '[MyEffect1, MyEffect2]
--   </pre>
--   
--   More complex <a>Handles</a> instances are possible, but not generally
--   very useful.
type family Handles (t :: HandlerK) (eff :: EffectK) :: Bool

-- | Boolean equality on types.
--   
--   This is essentially the same as <tt>==</tt> from
--   <a>Data.Type.Equality</a>, but the version from
--   <a>Data.Type.Equality</a> is written in such a way that allows GHC to
--   deduce more information from <tt>'<a>True</a></tt> results but causes
--   trouble when trying to compute the equality of rigid type variables.
--   This definition uses a simpler version.
type family a == b

-- | Checks if <tt>x</tt> is in the type-level list <tt>xs</tt> (like
--   <a>elem</a>, but at the type level).
type family Elem (x :: k) (xs :: [k]) :: Bool

-- | A helper for defining effect handlers in terms of other, existing
--   handlers. <tt>(<a>HandlerT</a> tag ts)</tt> is equivalent to
--   <tt>(<a>EffsT</a> ts)</tt>, but the phantom <tt>tag</tt> parameter is
--   useful as a way to disambiguate between different handler instances.
newtype HandlerT tag ts m a
HandlerT :: EffsT ts m a -> HandlerT tag ts m a
[runHandlerT] :: HandlerT tag ts m a -> EffsT ts m a

module Control.Effect.Writer

-- | <tt><a>Writer</a> w</tt> is an effect that allows the accumulation of
--   monoidal values of type <tt>w</tt>.
--   
--   Instances should obey the following laws:
--   
--   <ul>
--   <li><pre><a>tell</a> <i>x</i> <a>*&gt;</a> <a>tell</a> <i>y</i> ≡
--   <a>tell</a> (<i>x</i> <a>&lt;&gt;</a> <i>y</i>)</pre></li>
--   <li><pre><a>listen</a> (<a>tell</a> <i>x</i>) ≡ (<i>x</i>,)
--   <a>&lt;$&gt;</a> <a>tell</a> <i>x</i></pre></li>
--   <li><pre><a>censor</a> <i>f</i> (<a>tell</a> <i>x</i>) ≡ <a>tell</a>
--   (<i>f</i> <i>x</i>)</pre></li>
--   </ul>
class (Monoid w, Monad m) => Writer w m

-- | Appends the given value to the current output.
tell :: Writer w m => w -> m ()

-- | Executes the given action and includes its output in the result.
listen :: Writer w m => m a -> m (w, a)

-- | Executes the given action and modifies its output by applying the
--   given function.
censor :: Writer w m => (w -> w) -> m a -> m a
runWriter :: (Monoid w, Functor m) => EffT (WriterT w) m a -> m (w, a)
evalWriter :: (Monoid w, Monad m) => EffT (WriterT w) m a -> m a
execWriter :: (Monoid w, Monad m) => EffT (WriterT w) m a -> m w

-- | This handler is implemented on top of <a>StateT</a> rather than using
--   a <tt>WriterT</tt> implementation from <tt>transformers</tt> because
--   both the strict and lazy <tt>WriterT</tt> transformers leak space, and
--   <tt><a>Control.Monad.Trans.Writer.CPS</a></tt> does not expose the
--   <tt>WriterT</tt> constructor, precluding an efficient implementation
--   of <a>MonadTransControl</a>.
type WriterT w = HandlerT WriterH '[StateT w]
instance (GHC.Base.Monoid w, GHC.Base.Monad m) => Control.Effect.Writer.Writer w (Control.Effect.Writer.WriterT w m)
instance (GHC.Base.Monoid w, GHC.Base.Monad (t m), Control.Effect.Internal.Send (Control.Effect.Writer.Writer w) t m) => Control.Effect.Writer.Writer w (Control.Effect.Internal.EffT t m)
